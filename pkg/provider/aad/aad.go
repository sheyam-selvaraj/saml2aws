package aad

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"

	"github.com/versent/saml2aws/v2/pkg/cfg"
	"github.com/versent/saml2aws/v2/pkg/creds"
	"github.com/versent/saml2aws/v2/pkg/prompter"
	"github.com/versent/saml2aws/v2/pkg/provider"
)

var logger = logrus.WithField("provider", "AzureAD")

// Client wrapper around AzureAD enabling authentication and retrieval of assertions
type Client struct {
	provider.ValidateBase

	client     *provider.HTTPClient
	idpAccount *cfg.IDPAccount
}

// Autogenrated Converged Response struct
// for some cases, some fields may not exist
type ConvergedResponse struct {
	URLGetCredentialType    string             `json:"urlGetCredentialType"`
	ArrUserProofs           []userProof        `json:"arrUserProofs"`
	URLSkipMfaRegistration  string             `json:"urlSkipMfaRegistration"`
	OPerAuthPollingInterval map[string]float64 `json:"oPerAuthPollingInterval"`
	URLBeginAuth            string             `json:"urlBeginAuth"`
	URLEndAuth              string             `json:"urlEndAuth"`
	URLPost                 string             `json:"urlPost"`
	SErrorCode              string             `json:"sErrorCode"`
	SErrTxt                 string             `json:"sErrTxt"`
	SPOSTUsername           string             `json:"sPOST_Username"`
	SFT                     string             `json:"sFT"`
	SFTName                 string             `json:"sFTName"`
	SCtx                    string             `json:"sCtx"`
	Hpgact                  int                `json:"hpgact"`
	Hpgid                   int                `json:"hpgid"`
	Pgid                    string             `json:"pgid"`
	APICanary               string             `json:"apiCanary"`
	Canary                  string             `json:"canary"`
	CorrelationID           string             `json:"correlationId"`
	SessionID               string             `json:"sessionId"`
}

// Autogenerated GetCredentialType Request struct
// for some cases, some fields may not exist
type GetCredentialTypeRequest struct {
	Username                       string `json:"username"`
	IsOtherIdpSupported            bool   `json:"isOtherIdpSupported"`
	CheckPhones                    bool   `json:"checkPhones"`
	IsRemoteNGCSupported           bool   `json:"isRemoteNGCSupported"`
	IsCookieBannerShown            bool   `json:"isCookieBannerShown"`
	IsFidoSupported                bool   `json:"isFidoSupported"`
	OriginalRequest                string `json:"originalRequest"`
	Country                        string `json:"country"`
	Forceotclogin                  bool   `json:"forceotclogin"`
	IsExternalFederationDisallowed bool   `json:"isExternalFederationDisallowed"`
	IsRemoteConnectSupported       bool   `json:"isRemoteConnectSupported"`
	FederationFlags                int    `json:"federationFlags"`
	IsSignup                       bool   `json:"isSignup"`
	FlowToken                      string `json:"flowToken"`
	IsAccessPassSupported          bool   `json:"isAccessPassSupported"`
}

// Autogenerated GetCredentialType Response struct
// for some cases, some fields may not exist
type GetCredentialTypeResponse struct {
	Username       string `json:"Username"`
	Display        string `json:"Display"`
	IfExistsResult int    `json:"IfExistsResult"`
	IsUnmanaged    bool   `json:"IsUnmanaged"`
	ThrottleStatus int    `json:"ThrottleStatus"`
	Credentials    struct {
		PrefCredential        int         `json:"PrefCredential"`
		HasPassword           bool        `json:"HasPassword"`
		RemoteNgcParams       interface{} `json:"RemoteNgcParams"`
		FidoParams            interface{} `json:"FidoParams"`
		SasParams             interface{} `json:"SasParams"`
		CertAuthParams        interface{} `json:"CertAuthParams"`
		GoogleParams          interface{} `json:"GoogleParams"`
		FacebookParams        interface{} `json:"FacebookParams"`
		FederationRedirectURL string      `json:"FederationRedirectUrl"`
	} `json:"Credentials"`
	FlowToken          string `json:"FlowToken"`
	IsSignupDisallowed bool   `json:"IsSignupDisallowed"`
	APICanary          string `json:"apiCanary"`
}

// MFA Request struct
type mfaRequest struct {
	AuthMethodID       string `json:"AuthMethodId"`
	Method             string `json:"Method"`
	Ctx                string `json:"Ctx"`
	FlowToken          string `json:"FlowToken"`
	SessionID          string `json:"SessionId,omitempty"`
	AdditionalAuthData string `json:"AdditionalAuthData,omitempty"`
}

// MFA Response struct
type mfaResponse struct {
	Success       bool        `json:"Success"`
	ResultValue   string      `json:"ResultValue"`
	Message       interface{} `json:"Message"`
	AuthMethodID  string      `json:"AuthMethodId"`
	ErrCode       int         `json:"ErrCode"`
	Retry         bool        `json:"Retry"`
	FlowToken     string      `json:"FlowToken"`
	Ctx           string      `json:"Ctx"`
	SessionID     string      `json:"SessionId"`
	CorrelationID string      `json:"CorrelationId"`
	Timestamp     time.Time   `json:"Timestamp"`
	Entropy       int         `json:"Entropy"`
}

// A given method for a user to prove their indentity
type userProof struct {
	AuthMethodID string `json:"authMethodId"`
	Data         string `json:"data"`
	Display      string `json:"display"`
	IsDefault    bool   `json:"isDefault"`
}

// ConditionalAccessResponse struct for handling conditional access policy responses
type ConditionalAccessResponse struct {
	// Standard fields from ConvergedResponse
	SErrorCode string `json:"sErrorCode"`
	SErrTxt    string `json:"sErrTxt"`
	SFT        string `json:"sFT"`
	SFTName    string `json:"sFTName"`
	SCtx       string `json:"sCtx"`
	URLPost    string `json:"urlPost"`
	Canary     string `json:"canary"`
	SessionID  string `json:"sessionId"`

	// Conditional Access specific fields
	PolicyType        string   `json:"policyType,omitempty"`
	PolicyMessage     string   `json:"policyMessage,omitempty"`
	DeviceRegisterURL string   `json:"deviceRegisterUrl,omitempty"`
	ComplianceURL     string   `json:"complianceUrl,omitempty"`
	RequiredActions   []string `json:"requiredActions,omitempty"`
	Pgid              string   `json:"pgid"`
}

// New create a new AzureAD client
func New(idpAccount *cfg.IDPAccount) (*Client, error) {

	tr := &http.Transport{
		Proxy:           http.ProxyFromEnvironment,
		TLSClientConfig: &tls.Config{InsecureSkipVerify: idpAccount.SkipVerify, Renegotiation: tls.RenegotiateFreelyAsClient},
	}

	client, err := provider.NewHTTPClient(tr, provider.BuildHttpClientOpts(idpAccount))
	if err != nil {
		return nil, errors.Wrap(err, "error building http client")
	}

	return &Client{
		client:     client,
		idpAccount: idpAccount,
	}, nil
}

// Authenticate to AzureAD and return the data from the body of the SAML assertion.
func (ac *Client) Authenticate(loginDetails *creds.LoginDetails) (string, error) {
	var samlAssertion string
	var res *http.Response
	var err error
	var resBody []byte
	var resBodyStr string
	var convergedResponse *ConvergedResponse

	// idpAccount.URL = https://account.activedirectory.windowsazure.com

	// startSAML
	startURL := fmt.Sprintf("%s/applications/redirecttofederatedapplication.aspx?Operation=LinkedSignIn&applicationId=%s", ac.idpAccount.URL, ac.idpAccount.AppID)

	res, err = ac.client.Get(startURL)
	if err != nil {
		return samlAssertion, errors.Wrap(err, "error retrieving entry URL")
	}

AuthProcessor:
	for {
		resBody, _ = io.ReadAll(res.Body)
		resBodyStr = string(resBody)
		// reset res.Body so it can be read again later if required
		res.Body = io.NopCloser(bytes.NewBuffer(resBody))

		switch {
		case strings.Contains(resBodyStr, "ConvergedSignIn"):
			logger.Debug("processing ConvergedSignIn")
			res, err = ac.processConvergedSignIn(res, resBodyStr, loginDetails)
		case strings.Contains(resBodyStr, "ConvergedProofUpRedirect"):
			logger.Debug("processing ConvergedProofUpRedirect")
			res, err = ac.processConvergedProofUpRedirect(res, resBodyStr)
		case strings.Contains(resBodyStr, "KmsiInterrupt"):
			logger.Debug("processing KmsiInterrupt")
			res, err = ac.processKmsiInterrupt(res, resBodyStr)
		case strings.Contains(resBodyStr, "ConvergedTFA"):
			logger.Debug("processing ConvergedTFA")
			res, err = ac.processConvergedTFA(res, resBodyStr, loginDetails)
		case strings.Contains(resBodyStr, "ConvergedConditionalAccess"):
			logger.Debug("processing ConvergedConditionalAccess")
			res, err = ac.processConvergedConditionalAccess(res, resBodyStr, loginDetails)
		case strings.Contains(resBodyStr, "SAMLRequest"):
			logger.Debug("processing SAMLRequest")
			res, err = ac.processSAMLRequest(res, resBodyStr)
		case ac.isHiddenForm(resBodyStr):
			if samlAssertion, _ = ac.getSamlAssertion(resBodyStr); samlAssertion != "" {
				logger.Debug("processing a SAMLResponse")
				return samlAssertion, nil
			}
			logger.Debug("processing a 'hiddenform'")
			res, err = ac.reProcessForm(resBodyStr)
		default:
			if strings.Contains(resBodyStr, "$Config") {
				if err := ac.unmarshalEmbeddedJson(resBodyStr, &convergedResponse); err != nil {
					return samlAssertion, errors.Wrap(err, "unmarshal error")
				}
				logger.Debug("unknown process step found:", convergedResponse.Pgid)
			} else {
				logger.Debug("reached an unknown page within the authentication process")
			}
			break AuthProcessor
		}
		if err != nil {
			return samlAssertion, err
		}
	}

	return samlAssertion, errors.New("failed get SAMLAssertion")
}

func (ac *Client) processConvergedSignIn(res *http.Response, srcBodyStr string, loginDetails *creds.LoginDetails) (*http.Response, error) {
	var convergedResponse *ConvergedResponse
	var err error

	if err := ac.unmarshalEmbeddedJson(srcBodyStr, &convergedResponse); err != nil {
		return res, errors.Wrap(err, "ConvergedSignIn response unmarshal error")
	}

	loginRequestUrl := ac.fullUrl(res, convergedResponse.URLPost)

	refererUrl := res.Request.URL.String()

	getCredentialTypeResponse, _, err := ac.requestGetCredentialType(refererUrl, loginDetails, convergedResponse)
	if err != nil {
		return res, errors.Wrap(err, "error processing GetCredentialType request")
	}

	federationRedirectURL := getCredentialTypeResponse.Credentials.FederationRedirectURL

	if federationRedirectURL != "" {
		res, err = ac.processADFSAuthentication(federationRedirectURL, loginDetails)
		if err != nil {
			return res, err
		}
	} else {
		res, err = ac.processAuthentication(loginRequestUrl, refererUrl, loginDetails, convergedResponse)
		if err != nil {
			return res, err
		}
	}

	return res, nil
}

func (ac *Client) requestGetCredentialType(refererUrl string, loginDetails *creds.LoginDetails, convergedResponse *ConvergedResponse) (GetCredentialTypeResponse, *http.Response, error) {
	var res *http.Response
	var getCredentialTypeResponse GetCredentialTypeResponse

	reqBodyObj := GetCredentialTypeRequest{
		Username:             loginDetails.Username,
		IsOtherIdpSupported:  true,
		CheckPhones:          false,
		IsRemoteNGCSupported: false,
		IsCookieBannerShown:  false,
		IsFidoSupported:      false,
		OriginalRequest:      convergedResponse.SCtx,
		FlowToken:            convergedResponse.SFT,
	}
	reqBodyJson, err := json.Marshal(reqBodyObj)
	if err != nil {
		return getCredentialTypeResponse, res, errors.Wrap(err, "failed to build GetCredentialType request JSON")
	}

	req, err := http.NewRequest("POST", convergedResponse.URLGetCredentialType, strings.NewReader(string(reqBodyJson)))
	if err != nil {
		return getCredentialTypeResponse, res, errors.Wrap(err, "error building GetCredentialType request")
	}

	req.Header.Add("canary", convergedResponse.APICanary)
	req.Header.Add("client-request-id", convergedResponse.CorrelationID)
	req.Header.Add("hpgact", fmt.Sprint(convergedResponse.Hpgact))
	req.Header.Add("hpgid", fmt.Sprint(convergedResponse.Hpgid))
	req.Header.Add("hpgrequestid", convergedResponse.SessionID)
	req.Header.Add("Referer", refererUrl)

	res, err = ac.client.Do(req)
	if err != nil {
		return getCredentialTypeResponse, res, errors.Wrap(err, "error retrieving GetCredentialType results")
	}

	err = json.NewDecoder(res.Body).Decode(&getCredentialTypeResponse)
	if err != nil {
		return getCredentialTypeResponse, res, errors.Wrap(err, "error decoding GetCredentialType results")
	}

	return getCredentialTypeResponse, res, nil
}

func (ac *Client) processADFSAuthentication(federationUrl string, loginDetails *creds.LoginDetails) (*http.Response, error) {
	var res *http.Response
	var err error
	var resBodyStr string
	var formValues url.Values
	var formSubmitUrl string
	var req *http.Request

	res, err = ac.client.Get(federationUrl)
	if err != nil {
		return res, errors.Wrap(err, "error retrieving ADFS url")
	}

	resBodyStr, _ = ac.responseBodyAsString(res.Body)

	formValues, formSubmitUrl, err = ac.reSubmitFormData(resBodyStr)
	if err != nil {
		return res, errors.Wrap(err, "failed to parse ADFS login form")
	}

	if formSubmitUrl == "" {
		return res, fmt.Errorf("unable to locate ADFS form submit URL")
	}

	formValues.Set("UserName", loginDetails.Username)
	formValues.Set("Password", loginDetails.Password)
	formValues.Set("AuthMethod", "FormsAuthentication")

	req, err = http.NewRequest("POST", ac.fullUrl(res, formSubmitUrl), strings.NewReader(formValues.Encode()))
	if err != nil {
		return res, errors.Wrap(err, "error building ADFS login request")
	}

	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	res, err = ac.client.Do(req)
	if err != nil {
		return res, errors.Wrap(err, "error retrieving ADFS login results")
	}

	return res, nil
}

func (ac *Client) processAuthentication(loginUrl string, refererUrl string, loginDetails *creds.LoginDetails, convergedResponse *ConvergedResponse) (*http.Response, error) {
	var res *http.Response
	var err error
	var req *http.Request

	// 50058: user is not signed in (yet)
	if convergedResponse.SErrorCode != "" && convergedResponse.SErrorCode != "50058" {
		return res, fmt.Errorf("login error %s", convergedResponse.SErrorCode)
	}

	formValues := url.Values{}
	formValues.Set("canary", convergedResponse.Canary)
	formValues.Set("hpgrequestid", convergedResponse.SessionID)
	formValues.Set(convergedResponse.SFTName, convergedResponse.SFT)
	formValues.Set("ctx", convergedResponse.SCtx)
	formValues.Set("login", loginDetails.Username)
	formValues.Set("loginfmt", loginDetails.Username)
	formValues.Set("passwd", loginDetails.Password)

	req, err = http.NewRequest("POST", loginUrl, strings.NewReader(formValues.Encode()))
	if err != nil {
		return res, errors.Wrap(err, "error building login request")
	}

	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Add("Referer", refererUrl)

	res, err = ac.client.Do(req)
	if err != nil {
		return res, errors.Wrap(err, "error retrieving login results")
	}

	return res, nil
}

func (ac *Client) processKmsiInterrupt(res *http.Response, srcBodyStr string) (*http.Response, error) {
	var convergedResponse *ConvergedResponse
	var err error

	if err := ac.unmarshalEmbeddedJson(srcBodyStr, &convergedResponse); err != nil {
		return res, errors.Wrap(err, "KMSI request unmarshal error")
	}

	formValues := url.Values{}
	formValues.Set(convergedResponse.SFTName, convergedResponse.SFT)
	formValues.Set("ctx", convergedResponse.SCtx)
	formValues.Set("LoginOptions", "1")

	req, err := http.NewRequest("POST", ac.fullUrl(res, convergedResponse.URLPost), strings.NewReader(formValues.Encode()))
	if err != nil {
		return res, errors.Wrap(err, "error building KMSI request")
	}

	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	ac.client.DisableFollowRedirect()
	res, err = ac.client.Do(req)
	if err != nil {
		return res, errors.Wrap(err, "error retrieving KMSI results")
	}
	ac.client.EnableFollowRedirect()

	return res, nil
}

func (ac *Client) processConvergedTFA(res *http.Response, srcBodyStr string, loginDetails *creds.LoginDetails) (*http.Response, error) {
	var convergedResponse *ConvergedResponse
	var err error

	if err := ac.unmarshalEmbeddedJson(srcBodyStr, &convergedResponse); err != nil {
		return res, errors.Wrap(err, "ConvergedTFA response unmarshal error")
	}

	mfas := convergedResponse.ArrUserProofs

	// if there's an explicit option to skip MFA, do so
	if convergedResponse.URLSkipMfaRegistration != "" {
		res, err = ac.client.Get(convergedResponse.URLSkipMfaRegistration)
		if err != nil {
			return res, errors.Wrap(err, "error retrieving skip MFA results")
		}
	} else if len(mfas) != 0 {
		// there's no explicit option to skip MFA, and MFA options are available
		res, err = ac.processMfa(mfas, convergedResponse, loginDetails)
		if err != nil {
			return res, err
		}
	}

	return res, nil
}

func (ac *Client) processMfa(mfas []userProof, convergedResponse *ConvergedResponse, loginDetails *creds.LoginDetails) (*http.Response, error) {
	var res *http.Response
	var err error
	var mfaResp mfaResponse

	if len(mfas) == 0 {
		return res, fmt.Errorf("MFA not found")
	}

	mfaResp, err = ac.processMfaBeginAuth(mfas, convergedResponse)
	if err != nil {
		return res, errors.Wrap(err, "error processing MFA BeginAuth")
	}

	for i := 0; ; i++ {
		mfaReq := mfaRequest{
			AuthMethodID: mfaResp.AuthMethodID,
			Method:       "EndAuth",
			Ctx:          mfaResp.Ctx,
			FlowToken:    mfaResp.FlowToken,
			SessionID:    mfaResp.SessionID,
		}
		if mfaReq.AuthMethodID == "PhoneAppOTP" || mfaReq.AuthMethodID == "OneWaySMS" {
			if loginDetails.MFAToken != "" {
				mfaReq.AdditionalAuthData = loginDetails.MFAToken
			} else {
				verifyCode := prompter.StringRequired("Enter verification code")
				mfaReq.AdditionalAuthData = verifyCode
			}
		}
		if mfaReq.AuthMethodID == "PhoneAppNotification" && i == 0 {
			if mfaResp.Entropy == 0 {
				prompter.Display("Phone approval required.")
			} else {
				prompter.Display(fmt.Sprintf("Phone approval required. Entropy is: %d", mfaResp.Entropy))
			}
		}

		mfaResp, err = ac.processMfaEndAuth(mfaReq, convergedResponse)
		if err != nil {
			return res, errors.Wrap(err, "error processing MFA EndAuth")
		}

		if mfaResp.ErrCode != 0 {
			return res, fmt.Errorf("error processing MFA, errcode: %d, message: %v", mfaResp.ErrCode, mfaResp.Message)
		}

		if mfaResp.Success {
			break
		}
		if !mfaResp.Retry {
			break
		}

		// if mfaResp.Retry == true then
		// must exist convergedResponse.OPerAuthPollingInterval[mfaResp.AuthMethodID]
		time.Sleep(time.Duration(convergedResponse.OPerAuthPollingInterval[mfaResp.AuthMethodID]) * time.Second)
	}

	if !mfaResp.Success {
		return res, fmt.Errorf("error processing MFA")
	}

	res, err = ac.processMfaAuth(mfaResp, convergedResponse)
	if err != nil {
		return res, errors.Wrap(err, "error processing MFA ProcessAuth")
	}

	return res, nil
}

func (ac *Client) processMfaBeginAuth(mfas []userProof, convergedResponse *ConvergedResponse) (mfaResponse, error) {
	var res *http.Response
	var err error
	var mfaResp mfaResponse
	var req *http.Request

	mfa := mfas[0]
	switch ac.idpAccount.MFA {
	case "Auto":
		for _, v := range mfas {
			if v.IsDefault {
				mfa = v
				break
			}
		}
	default:
		for _, v := range mfas {
			if v.AuthMethodID == ac.idpAccount.MFA {
				mfa = v
				break
			}
		}
	}
	mfaReqObj := mfaRequest{
		AuthMethodID: mfa.AuthMethodID,
		Method:       "BeginAuth",
		Ctx:          convergedResponse.SCtx,
		FlowToken:    convergedResponse.SFT,
	}
	mfaReqJson, err := json.Marshal(mfaReqObj)
	if err != nil {
		return mfaResp, errors.Wrap(err, "failed to build MFA BeginAuth request body")
	}

	req, err = http.NewRequest("POST", convergedResponse.URLBeginAuth, strings.NewReader(string(mfaReqJson)))
	if err != nil {
		return mfaResp, errors.Wrap(err, "error building MFA BeginAuth request")
	}

	req.Header.Add("Content-Type", "application/json")

	res, err = ac.client.Do(req)
	if err != nil {
		return mfaResp, errors.Wrap(err, "error retrieving MFA BeginAuth results")
	}

	err = json.NewDecoder(res.Body).Decode(&mfaResp)
	if err != nil {
		return mfaResp, errors.Wrap(err, "error decoding MFA BeginAuth results")
	}

	if !mfaResp.Success {
		return mfaResp, fmt.Errorf("MFA BeginAuth result is not success: %v", mfaResp.Message)
	}

	return mfaResp, nil
}

func (ac *Client) processMfaEndAuth(mfaReqObj mfaRequest, convergedResponse *ConvergedResponse) (mfaResponse, error) {
	var res *http.Response
	var err error
	var mfaResp mfaResponse
	var req *http.Request

	mfaReqJson, err := json.Marshal(mfaReqObj)
	if err != nil {
		return mfaResp, errors.Wrap(err, "failed to build MFA EndAuth request body")
	}

	req, err = http.NewRequest("POST", convergedResponse.URLEndAuth, strings.NewReader(string(mfaReqJson)))
	if err != nil {
		return mfaResp, errors.Wrap(err, "error building MFA EndAuth request")
	}

	req.Header.Add("Content-Type", "application/json")

	res, err = ac.client.Do(req)
	if err != nil {
		return mfaResp, errors.Wrap(err, "error retrieving MFA EndAuth results")
	}

	err = json.NewDecoder(res.Body).Decode(&mfaResp)
	if err != nil {
		return mfaResp, errors.Wrap(err, "error decoding MFA EndAuth results")
	}

	return mfaResp, nil
}

func (ac *Client) processMfaAuth(mfaResp mfaResponse, convergedResponse *ConvergedResponse) (*http.Response, error) {
	var res *http.Response
	var err error
	var req *http.Request

	formValues := url.Values{}
	formValues.Set(convergedResponse.SFTName, mfaResp.FlowToken)
	formValues.Set("request", mfaResp.Ctx)
	formValues.Set("login", convergedResponse.SPOSTUsername)

	req, err = http.NewRequest("POST", convergedResponse.URLPost, strings.NewReader(formValues.Encode()))
	if err != nil {
		return res, errors.Wrap(err, "error building MFA ProcessAuth request")
	}

	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	res, err = ac.client.Do(req)
	if err != nil {
		return res, errors.Wrap(err, "error retrieving MFA ProcessAuth results")
	}

	return res, nil
}

func (ac *Client) processSAMLRequest(res *http.Response, srcBodyStr string) (*http.Response, error) {
	var err error

	// data is embedded javascript
	// window.location = 'https:/..../?SAMLRequest=......'
	oidcResponseList := strings.Split(srcBodyStr, ";")
	var samlRequestUrl string
	for _, v := range oidcResponseList {
		if strings.Contains(v, "SAMLRequest") {
			startURLPos := strings.Index(v, "https://")
			endURLPos := strings.Index(v[startURLPos:], "'")
			if endURLPos == -1 {
				endURLPos = strings.Index(v[startURLPos:], "\"")
			}
			samlRequestUrl = v[startURLPos : startURLPos+endURLPos]
		}
	}
	if samlRequestUrl == "" {
		return res, fmt.Errorf("unable to locate SAMLRequest URL")
	}

	res, err = ac.client.Get(samlRequestUrl)
	if err != nil {
		return res, errors.Wrap(err, "error retrieving SAMLRequest results")
	}

	return res, nil
}

func (ac *Client) processConvergedProofUpRedirect(res *http.Response, srcBodyStr string) (*http.Response, error) {
	var convergedResponse *ConvergedResponse
	var err error

	if err := ac.unmarshalEmbeddedJson(srcBodyStr, &convergedResponse); err != nil {
		return res, errors.Wrap(err, "skip MFA response unmarshal error")
	}

	// 50058: user is not signed in (yet)
	if convergedResponse.SErrorCode != "" && convergedResponse.SErrorCode != "50058" {
		return res, fmt.Errorf("login error %s", convergedResponse.SErrorCode)
	}

	if convergedResponse.URLSkipMfaRegistration == "" {
		return res, fmt.Errorf("skip MFA not possible")
	}

	res, err = ac.client.Get(convergedResponse.URLSkipMfaRegistration)
	if err != nil {
		return res, errors.Wrap(err, "error processing skip MFA request")
	}

	return res, nil
}

func (ac *Client) processConvergedConditionalAccess(res *http.Response, srcBodyStr string, loginDetails *creds.LoginDetails) (*http.Response, error) {
	var conditionalAccessResponse *ConditionalAccessResponse

	logger.Debug("Starting conditional access response processing")

	if err := ac.unmarshalEmbeddedJson(srcBodyStr, &conditionalAccessResponse); err != nil {
		logger.WithFields(logrus.Fields{
			"error": err.Error(),
		}).Debug("Failed to unmarshal conditional access response")
		return res, errors.Wrap(err, "ConvergedConditionalAccess response unmarshal error")
	}

	// Log raw response details for debugging (excluding sensitive data)
	logger.WithFields(logrus.Fields{
		"pgid":                 conditionalAccessResponse.Pgid,
		"errorCode":            conditionalAccessResponse.SErrorCode,
		"hasErrorText":         conditionalAccessResponse.SErrTxt != "",
		"hasDeviceRegisterURL": conditionalAccessResponse.DeviceRegisterURL != "",
		"hasComplianceURL":     conditionalAccessResponse.ComplianceURL != "",
		"hasRequiredActions":   len(conditionalAccessResponse.RequiredActions) > 0,
		"requiredActionsCount": len(conditionalAccessResponse.RequiredActions),
		"sessionIdPresent":     conditionalAccessResponse.SessionID != "",
	}).Debug("Conditional access response details")

	// Detect policy type based on response content
	policyType := ac.detectConditionalAccessPolicyType(conditionalAccessResponse, srcBodyStr)

	// Log policy detection results
	logger.WithFields(logrus.Fields{
		"detectedPolicyType": policyType,
		"errorCode":          conditionalAccessResponse.SErrorCode,
		"pgid":               conditionalAccessResponse.Pgid,
		"hasErrorMessage":    conditionalAccessResponse.SErrTxt != "",
	}).Debug("Conditional access policy type detected")

	// Log specific policy details based on type
	ac.logPolicySpecificDetails(policyType, conditionalAccessResponse)

	// Log available resolution options
	ac.logResolutionOptions(conditionalAccessResponse)

	logger.WithFields(logrus.Fields{
		"policyType": policyType,
		"errorCode":  conditionalAccessResponse.SErrorCode,
	}).Debug("Conditional access policy enforced - authentication blocked")

	// Handle the conditional access error with appropriate messaging
	return res, ac.handleConditionalAccessError(conditionalAccessResponse, policyType)
}

func (ac *Client) unmarshalEmbeddedJson(resBodyStr string, v any) error {
	/*
	 * data is embedded in a javascript object
	 * <script><![CDATA[  $Config=......; ]]>
	 */
	startIndex := strings.Index(resBodyStr, "$Config=") + 8
	return json.NewDecoder(strings.NewReader(resBodyStr[startIndex:])).Decode(&v)
}

func (ac *Client) responseBodyAsString(body io.ReadCloser) (string, error) {
	resBody, err := io.ReadAll(body)
	return string(resBody), err
}

func (ac *Client) fullUrl(res *http.Response, urlFragment string) string {
	if strings.HasPrefix(urlFragment, "/") {
		return res.Request.URL.Scheme + "://" + res.Request.URL.Host + urlFragment
	} else {
		return urlFragment
	}
}

func (ac *Client) isHiddenForm(resBodyStr string) bool {
	return strings.HasPrefix(resBodyStr, "<html><head><title>Working...</title>") && strings.Contains(resBodyStr, "name=\"hiddenform\"")
}

func (ac *Client) reProcessForm(srcBodyStr string) (*http.Response, error) {
	var res *http.Response
	var err error
	var formValues url.Values
	var formSubmitUrl string

	formValues, formSubmitUrl, err = ac.reSubmitFormData(srcBodyStr)
	if err != nil {
		return res, errors.Wrap(err, "failed to parse hiddenform form")
	}

	if formSubmitUrl == "" {
		return res, fmt.Errorf("unable to locate hiddenform submit URL")
	}

	req, err := http.NewRequest("POST", formSubmitUrl, strings.NewReader(formValues.Encode()))
	if err != nil {
		return res, errors.Wrap(err, "error building hiddenform request")
	}

	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	res, err = ac.client.Do(req)
	if err != nil {
		return res, errors.Wrap(err, "error retrieving hiddenform results")
	}

	return res, nil
}

func (ac *Client) reSubmitFormData(resBodyStr string) (url.Values, string, error) {
	formValues := url.Values{}
	var formSubmitUrl string

	doc, err := goquery.NewDocumentFromReader(strings.NewReader(resBodyStr))
	if err != nil {
		return formValues, formSubmitUrl, errors.Wrap(err, "failed to build document from response")
	}

	// prefil form data from page as provided
	doc.Find("input").Each(func(i int, s *goquery.Selection) {
		name, ok := s.Attr("name")
		if !ok {
			return
		}
		value, ok := s.Attr("value")
		if !ok {
			return
		}
		formValues.Set(name, value)
	})

	// identify form submit url/path
	doc.Find("form").Each(func(i int, s *goquery.Selection) {
		action, ok := s.Attr("action")
		if !ok {
			return
		}
		formSubmitUrl = action
	})

	return formValues, formSubmitUrl, nil
}

func (ac *Client) getSamlAssertion(resBodyStr string) (string, error) {
	var samlAssertion string

	doc, err := goquery.NewDocumentFromReader(strings.NewReader(resBodyStr))
	if err != nil {
		return samlAssertion, errors.Wrap(err, "failed to build document from response")
	}

	doc.Find("input").Each(func(i int, s *goquery.Selection) {
		attrName, ok := s.Attr("name")
		if !ok {
			return
		}
		if attrName != "SAMLResponse" {
			return
		}
		samlAssertion, _ = s.Attr("value")
	})

	return samlAssertion, nil
}

// logPolicySpecificDetails logs detailed information based on the detected policy type
func (ac *Client) logPolicySpecificDetails(policyType string, caResp *ConditionalAccessResponse) {
	switch policyType {
	case "device_compliance":
		logger.WithFields(logrus.Fields{
			"policyType":           policyType,
			"hasDeviceRegisterURL": caResp.DeviceRegisterURL != "",
			"hasComplianceURL":     caResp.ComplianceURL != "",
		}).Debug("Device compliance policy details")

		if caResp.DeviceRegisterURL != "" {
			logger.WithFields(logrus.Fields{
				"deviceRegisterURLPresent": true,
			}).Debug("Device registration URL available for resolution")
		}

	case "location_based":
		logger.WithFields(logrus.Fields{
			"policyType": policyType,
		}).Debug("Location-based policy detected - manual resolution required")

	case "application_based":
		logger.WithFields(logrus.Fields{
			"policyType":         policyType,
			"hasRequiredActions": len(caResp.RequiredActions) > 0,
		}).Debug("Application-based policy details")

		if len(caResp.RequiredActions) > 0 {
			logger.WithFields(logrus.Fields{
				"requiredActionsCount": len(caResp.RequiredActions),
			}).Debug("Required actions specified for application policy")
		}

	case "risk_based":
		logger.WithFields(logrus.Fields{
			"policyType": policyType,
		}).Debug("Risk-based policy detected - identity verification required")

	default:
		logger.WithFields(logrus.Fields{
			"policyType": policyType,
			"errorCode":  caResp.SErrorCode,
		}).Debug("Unknown conditional access policy type detected")
	}
}

// logResolutionOptions logs available resolution options and URLs
func (ac *Client) logResolutionOptions(caResp *ConditionalAccessResponse) {
	resolutionOptions := make(map[string]interface{})

	if caResp.DeviceRegisterURL != "" {
		resolutionOptions["deviceRegistration"] = true
		logger.Debug("Device registration URL available for manual resolution")
	}

	if caResp.ComplianceURL != "" {
		resolutionOptions["complianceCheck"] = true
		logger.Debug("Compliance URL available for manual resolution")
	}

	if len(caResp.RequiredActions) > 0 {
		resolutionOptions["requiredActions"] = len(caResp.RequiredActions)
		logger.WithFields(logrus.Fields{
			"actionsCount": len(caResp.RequiredActions),
		}).Debug("Required actions specified for policy resolution")
	}

	if len(resolutionOptions) == 0 {
		logger.Debug("No automatic resolution options available - manual intervention required")
	} else {
		logger.WithFields(logrus.Fields{
			"availableOptions": resolutionOptions,
		}).Debug("Resolution options available for conditional access policy")
	}
}

// detectConditionalAccessPolicyType analyzes the conditional access response to determine the policy type
func (ac *Client) detectConditionalAccessPolicyType(caResp *ConditionalAccessResponse, srcBodyStr string) string {
	logger.Debug("Starting conditional access policy type detection")

	// Check for explicit policy type in response
	if caResp.PolicyType != "" {
		logger.WithFields(logrus.Fields{
			"explicitPolicyType": caResp.PolicyType,
		}).Debug("Explicit policy type found in response")
		return caResp.PolicyType
	}

	// Analyze error codes and messages to determine policy type
	errorCode := caResp.SErrorCode
	errorMessage := strings.ToLower(caResp.SErrTxt)
	bodyContent := strings.ToLower(srcBodyStr)

	logger.WithFields(logrus.Fields{
		"errorCode":       errorCode,
		"hasErrorMessage": errorMessage != "",
		"bodyContentSize": len(bodyContent),
	}).Debug("Analyzing response content for policy type detection")

	// Device compliance policy detection
	deviceKeywords := []string{"device", "compliance", "managed"}
	deviceCodes := []string{"53003", "53004"}
	if ac.containsAnyKeyword(errorMessage, deviceKeywords) || ac.containsAnyKeyword(bodyContent, deviceKeywords) ||
		ac.containsAnyCode(errorCode, deviceCodes) {
		logger.WithFields(logrus.Fields{
			"detectedType":     "device_compliance",
			"matchedErrorCode": ac.containsAnyCode(errorCode, deviceCodes),
			"matchedKeywords":  ac.getMatchedKeywords(errorMessage, deviceKeywords),
		}).Debug("Device compliance policy detected")
		return "device_compliance"
	}

	// Location-based policy detection
	locationKeywords := []string{"location", "trusted", "network"}
	locationCodes := []string{"53000", "53001"}
	if ac.containsAnyKeyword(errorMessage, locationKeywords) || ac.containsAnyKeyword(bodyContent, locationKeywords) ||
		ac.containsAnyCode(errorCode, locationCodes) {
		logger.WithFields(logrus.Fields{
			"detectedType":     "location_based",
			"matchedErrorCode": ac.containsAnyCode(errorCode, locationCodes),
			"matchedKeywords":  ac.getMatchedKeywords(errorMessage, locationKeywords),
		}).Debug("Location-based policy detected")
		return "location_based"
	}

	// Application-based policy detection
	appKeywords := []string{"application", "app", "permission", "consent"}
	appCodes := []string{"65001", "65004"}
	if ac.containsAnyKeyword(errorMessage, appKeywords) || ac.containsAnyKeyword(bodyContent, appKeywords) ||
		ac.containsAnyCode(errorCode, appCodes) {
		logger.WithFields(logrus.Fields{
			"detectedType":     "application_based",
			"matchedErrorCode": ac.containsAnyCode(errorCode, appCodes),
			"matchedKeywords":  ac.getMatchedKeywords(errorMessage, appKeywords),
		}).Debug("Application-based policy detected")
		return "application_based"
	}

	// Risk-based policy detection
	riskKeywords := []string{"risk", "suspicious", "anomalous", "identity protection"}
	riskCodes := []string{"50053", "50055", "50057"}
	if ac.containsAnyKeyword(errorMessage, riskKeywords) || ac.containsAnyKeyword(bodyContent, riskKeywords) ||
		ac.containsAnyCode(errorCode, riskCodes) {
		logger.WithFields(logrus.Fields{
			"detectedType":     "risk_based",
			"matchedErrorCode": ac.containsAnyCode(errorCode, riskCodes),
			"matchedKeywords":  ac.getMatchedKeywords(errorMessage, riskKeywords),
		}).Debug("Risk-based policy detected")
		return "risk_based"
	}

	// Default to unknown if no specific pattern is detected
	logger.WithFields(logrus.Fields{
		"detectedType": "unknown",
		"errorCode":    errorCode,
	}).Debug("No specific policy type pattern detected - defaulting to unknown")

	return "unknown"
}

// containsAnyKeyword checks if any of the keywords are present in the text
func (ac *Client) containsAnyKeyword(text string, keywords []string) bool {
	for _, keyword := range keywords {
		if strings.Contains(text, keyword) {
			return true
		}
	}
	return false
}

// containsAnyCode checks if the error code matches any of the specified codes
func (ac *Client) containsAnyCode(errorCode string, codes []string) bool {
	for _, code := range codes {
		if errorCode == code {
			return true
		}
	}
	return false
}

// getMatchedKeywords returns a list of keywords that were found in the text
func (ac *Client) getMatchedKeywords(text string, keywords []string) []string {
	var matched []string
	for _, keyword := range keywords {
		if strings.Contains(text, keyword) {
			matched = append(matched, keyword)
		}
	}
	return matched
}

// validateMicrosoftURL validates that a URL is from a trusted Microsoft domain
func (ac *Client) validateMicrosoftURL(urlStr string) bool {
	if urlStr == "" {
		return false
	}

	parsedURL, err := url.Parse(urlStr)
	if err != nil {
		logger.WithFields(logrus.Fields{
			"url":   urlStr,
			"error": err.Error(),
		}).Debug("Failed to parse URL for validation")
		return false
	}

	// List of trusted Microsoft domains for conditional access URLs
	trustedDomains := []string{
		"login.microsoftonline.com",
		"account.activedirectory.windowsazure.com",
		"portal.azure.com",
		"aad.portal.azure.com",
		"devicemanagement.microsoft.com",
		"endpoint.microsoft.com",
		"compliance.microsoft.com",
		"security.microsoft.com",
		"mysignins.microsoft.com",
		"myaccount.microsoft.com",
		"aka.ms",
	}

	hostname := strings.ToLower(parsedURL.Hostname())

	// Check exact domain matches
	for _, domain := range trustedDomains {
		if hostname == domain {
			logger.WithFields(logrus.Fields{
				"url":              urlStr,
				"hostname":         hostname,
				"matchedDomain":    domain,
				"validationResult": "trusted",
			}).Debug("URL validated as trusted Microsoft domain")
			return true
		}
	}

	// Check subdomain matches for Microsoft domains
	microsoftSubdomains := []string{
		".microsoft.com",
		".microsoftonline.com",
		".windowsazure.com",
		".azure.com",
	}

	for _, subdomain := range microsoftSubdomains {
		if strings.HasSuffix(hostname, subdomain) {
			logger.WithFields(logrus.Fields{
				"url":              urlStr,
				"hostname":         hostname,
				"matchedSubdomain": subdomain,
				"validationResult": "trusted_subdomain",
			}).Debug("URL validated as trusted Microsoft subdomain")
			return true
		}
	}

	logger.WithFields(logrus.Fields{
		"url":              urlStr,
		"hostname":         hostname,
		"validationResult": "untrusted",
	}).Debug("URL validation failed - not a trusted Microsoft domain")

	return false
}

// extractAndValidateURLs extracts URLs from conditional access response and validates them
func (ac *Client) extractAndValidateURLs(caResp *ConditionalAccessResponse) map[string]string {
	validatedURLs := make(map[string]string)

	logger.Debug("Starting URL extraction and validation from conditional access response")

	// Extract and validate device registration URL
	if caResp.DeviceRegisterURL != "" {
		if ac.validateMicrosoftURL(caResp.DeviceRegisterURL) {
			validatedURLs["deviceRegistration"] = caResp.DeviceRegisterURL
			logger.WithFields(logrus.Fields{
				"urlType":   "deviceRegistration",
				"validated": true,
			}).Debug("Device registration URL extracted and validated")
		} else {
			logger.WithFields(logrus.Fields{
				"urlType":   "deviceRegistration",
				"validated": false,
				"reason":    "untrusted_domain",
			}).Debug("Device registration URL rejected - untrusted domain")
		}
	}

	// Extract and validate compliance URL
	if caResp.ComplianceURL != "" {
		if ac.validateMicrosoftURL(caResp.ComplianceURL) {
			validatedURLs["compliance"] = caResp.ComplianceURL
			logger.WithFields(logrus.Fields{
				"urlType":   "compliance",
				"validated": true,
			}).Debug("Compliance URL extracted and validated")
		} else {
			logger.WithFields(logrus.Fields{
				"urlType":   "compliance",
				"validated": false,
				"reason":    "untrusted_domain",
			}).Debug("Compliance URL rejected - untrusted domain")
		}
	}

	logger.WithFields(logrus.Fields{
		"extractedURLCount": len(validatedURLs),
		"availableURLTypes": getMapKeys(validatedURLs),
	}).Debug("URL extraction and validation completed")

	return validatedURLs
}

// generateActionableGuidance creates detailed guidance based on policy type and available URLs
func (ac *Client) generateActionableGuidance(policyType string, validatedURLs map[string]string, caResp *ConditionalAccessResponse) string {
	var guidance strings.Builder

	logger.WithFields(logrus.Fields{
		"policyType": policyType,
		"urlCount":   len(validatedURLs),
	}).Debug("Generating actionable guidance for conditional access policy")

	switch policyType {
	case "device_compliance":
		guidance.WriteString("DEVICE COMPLIANCE REQUIRED:\n")
		guidance.WriteString("Your device does not meet your organization's compliance requirements.\n\n")

		if deviceURL, exists := validatedURLs["deviceRegistration"]; exists {
			guidance.WriteString("IMMEDIATE ACTION REQUIRED:\n")
			guidance.WriteString(fmt.Sprintf("1. Visit the device registration portal: %s\n", deviceURL))
			guidance.WriteString("2. Follow the device enrollment process\n")
			guidance.WriteString("3. Wait for compliance evaluation (may take up to 24 hours)\n")
			guidance.WriteString("4. Retry authentication after compliance is confirmed\n\n")
		}

		if complianceURL, exists := validatedURLs["compliance"]; exists {
			guidance.WriteString("COMPLIANCE CHECK:\n")
			guidance.WriteString(fmt.Sprintf("• Check device compliance status: %s\n", complianceURL))
			guidance.WriteString("• Resolve any compliance issues identified\n\n")
		}

		if len(validatedURLs) == 0 {
			guidance.WriteString("MANUAL STEPS REQUIRED:\n")
			guidance.WriteString("• Contact your IT administrator for device enrollment assistance\n")
			guidance.WriteString("• Ensure your device meets organizational security requirements\n")
			guidance.WriteString("• Consider using a managed device if available\n\n")
		}

	case "location_based":
		guidance.WriteString("LOCATION RESTRICTION:\n")
		guidance.WriteString("Access is restricted based on your current location or network.\n\n")
		guidance.WriteString("RESOLUTION OPTIONS:\n")
		guidance.WriteString("• Connect to your organization's VPN if available\n")
		guidance.WriteString("• Access from an approved office location\n")
		guidance.WriteString("• Contact your administrator to review location policies\n")
		guidance.WriteString("• Verify your IP address is not blocked\n\n")

	case "application_based":
		guidance.WriteString("APPLICATION APPROVAL REQUIRED:\n")
		guidance.WriteString("Additional permissions or approvals are needed for this application.\n\n")
		guidance.WriteString("REQUIRED ACTIONS:\n")
		guidance.WriteString("• Contact your IT administrator for application approval\n")
		guidance.WriteString("• Request necessary permissions for saml2aws access\n")
		guidance.WriteString("• Verify the application is properly configured in Azure AD\n\n")

		if len(caResp.RequiredActions) > 0 {
			guidance.WriteString("SPECIFIC REQUIREMENTS:\n")
			for i, action := range caResp.RequiredActions {
				guidance.WriteString(fmt.Sprintf("%d. %s\n", i+1, action))
			}
			guidance.WriteString("\n")
		}

	case "risk_based":
		guidance.WriteString("SIGN-IN RISK DETECTED:\n")
		guidance.WriteString("Your sign-in attempt has been flagged as potentially risky.\n\n")
		guidance.WriteString("SECURITY ACTIONS:\n")
		guidance.WriteString("• Verify this sign-in attempt is legitimate\n")
		guidance.WriteString("• Change your password if you suspect compromise\n")
		guidance.WriteString("• Review recent sign-in activity in Azure AD\n")
		guidance.WriteString("• Contact security team if unauthorized access is suspected\n\n")

	default:
		guidance.WriteString("CONDITIONAL ACCESS POLICY ACTIVE:\n")
		guidance.WriteString("An organizational policy is preventing authentication.\n\n")
		guidance.WriteString("GENERAL RESOLUTION STEPS:\n")
		guidance.WriteString("• Contact your IT administrator for assistance\n")
		guidance.WriteString("• Provide the error details shown below\n")
		guidance.WriteString("• Verify your account status and permissions\n\n")
	}

	// Add common troubleshooting section
	guidance.WriteString("TROUBLESHOOTING INFORMATION:\n")
	if caResp.SErrorCode != "" {
		guidance.WriteString(fmt.Sprintf("• Error Code: %s\n", caResp.SErrorCode))
	}
	if caResp.SessionID != "" {
		guidance.WriteString(fmt.Sprintf("• Session ID: %s\n", caResp.SessionID))
	}
	if caResp.Pgid != "" {
		guidance.WriteString(fmt.Sprintf("• Process ID: %s\n", caResp.Pgid))
	}

	guidanceText := guidance.String()

	logger.WithFields(logrus.Fields{
		"policyType":     policyType,
		"guidanceLength": len(guidanceText),
		"urlsIncluded":   len(validatedURLs),
	}).Debug("Actionable guidance generated successfully")

	return guidanceText
}

// getMapKeys returns the keys of a string map as a slice
func getMapKeys(m map[string]string) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// handleConditionalAccessError generates user-friendly error messages for conditional access policies
func (ac *Client) handleConditionalAccessError(caResp *ConditionalAccessResponse, policyType string) error {
	logger.Debug("Generating enhanced conditional access error message with URL validation")

	// Log comprehensive policy details for debugging (excluding sensitive information)
	logger.WithFields(logrus.Fields{
		"policyType":           policyType,
		"errorCode":            caResp.SErrorCode,
		"hasErrorMessage":      caResp.SErrTxt != "",
		"errorMessageLength":   len(caResp.SErrTxt),
		"pgid":                 caResp.Pgid,
		"hasSessionId":         caResp.SessionID != "",
		"hasDeviceRegisterURL": caResp.DeviceRegisterURL != "",
		"hasComplianceURL":     caResp.ComplianceURL != "",
		"requiredActionsCount": len(caResp.RequiredActions),
	}).Debug("Conditional access error details for troubleshooting")

	// Extract and validate URLs from the response
	validatedURLs := ac.extractAndValidateURLs(caResp)

	logger.WithFields(logrus.Fields{
		"policyType":        policyType,
		"validatedURLCount": len(validatedURLs),
		"urlTypes":          getMapKeys(validatedURLs),
	}).Debug("URL extraction and validation completed for error message")

	// Generate comprehensive actionable guidance
	guidance := ac.generateActionableGuidance(policyType, validatedURLs, caResp)

	// Create the main error message
	var message strings.Builder
	message.WriteString(guidance)

	// Add original error details if available (non-sensitive information only)
	if caResp.SErrTxt != "" {
		message.WriteString(fmt.Sprintf("\nOriginal Error Message: %s\n", caResp.SErrTxt))
		logger.WithFields(logrus.Fields{
			"errorDetailsIncluded": true,
			"errorDetailsLength":   len(caResp.SErrTxt),
		}).Debug("Original error details included in user message")
	}

	finalMessage := message.String()

	// Log final error generation with security considerations
	logger.WithFields(logrus.Fields{
		"policyType":            policyType,
		"errorCode":             caResp.SErrorCode,
		"messageGenerated":      true,
		"guidanceIncluded":      true,
		"validatedURLsIncluded": len(validatedURLs),
		"messageLength":         len(finalMessage),
	}).Debug("Enhanced conditional access error message generated successfully")

	return fmt.Errorf("conditional access policy blocked authentication: %s", finalMessage)
}
